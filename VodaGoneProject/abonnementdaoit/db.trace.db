2016-12-08 20:56:38 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Unknown data type: "ENUM"; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum   date   not null,   verdubbeld   boolean    not null,  abonnementsoort enum('MAAND', 'HALFJAAR', 'JAAR'),  abonnementstatus enum('PROEF', 'ACTIEF', 'OPGEZEGD'),   primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade) [50004-193]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.Parser.parseColumnWithType(Parser.java:4080)
	at org.h2.command.Parser.parseColumnForTable(Parser.java:3938)
	at org.h2.command.Parser.parseCreateTable(Parser.java:5977)
	at org.h2.command.Parser.parseCreate(Parser.java:4238)
	at org.h2.command.Parser.parsePrepared(Parser.java:362)
	at org.h2.command.Parser.parse(Parser.java:317)
	at org.h2.command.Parser.parse(Parser.java:289)
	at org.h2.command.Parser.prepareCommand(Parser.java:254)
	at org.h2.engine.Session.prepareLocal(Session.java:561)
	at org.h2.engine.Session.prepareCommand(Session.java:502)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1203)
	at org.h2.jdbc.JdbcStatement.executeUpdateInternal(JdbcStatement.java:126)
	at org.h2.jdbc.JdbcStatement.executeUpdate(JdbcStatement.java:115)
	at oose.dea.datasource.AbonnementDAOIT.prepare(AbonnementDAOIT.java:50)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
2016-12-08 20:59:00 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Unknown data type: "ENUM"; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum   date   not null,   verdubbeld   boolean    not null,  abonnementsoort enum('MAAND', 'HALFJAAR', 'JAAR'),  abonnementstatus enum('PROEF', 'ACTIEF', 'OPGEZEGD'),   primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade,  check (abonnementsoort in ('MAAND', 'HALFJAAR','JAAR')),  check (abonnementstatus in ('PROEF', 'ACTIEF','OPGEZEGD'))) [50004-193]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.Parser.parseColumnWithType(Parser.java:4080)
	at org.h2.command.Parser.parseColumnForTable(Parser.java:3938)
	at org.h2.command.Parser.parseCreateTable(Parser.java:5977)
	at org.h2.command.Parser.parseCreate(Parser.java:4238)
	at org.h2.command.Parser.parsePrepared(Parser.java:362)
	at org.h2.command.Parser.parse(Parser.java:317)
	at org.h2.command.Parser.parse(Parser.java:289)
	at org.h2.command.Parser.prepareCommand(Parser.java:254)
	at org.h2.engine.Session.prepareLocal(Session.java:561)
	at org.h2.engine.Session.prepareCommand(Session.java:502)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1203)
	at org.h2.jdbc.JdbcStatement.executeUpdateInternal(JdbcStatement.java:126)
	at org.h2.jdbc.JdbcStatement.executeUpdate(JdbcStatement.java:115)
	at oose.dea.datasource.AbonnementDAOIT.prepare(AbonnementDAOIT.java:52)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
2016-12-08 21:04:13 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "CREATE TABLE IF NOT EXISTS ABONNEMENT (   ABONNEENAAM  VARCHAR(255) NOT NULL,  DIENSTNAAM  VARCHAR(255) NOT NULL,  ABONNEEDELEN1  VARCHAR(255)  NULL,  ABONNEEDELEN2  VARCHAR(255)  NULL,  STARTDATUM   DATE   NOT NULL,   VERDUBBELD   BOOLEAN    NOT NULL,  ABONNEMENTSOORT VARCHAR(20) CHECK (ABONNEMENTSOORT IN ('MAAND', 'HALFJAAR','JAAR')),  ABONNEMENTSTATUS VARCHAR(20)CHECK (ABONNEMENTSTATUS IN ('PROEF', 'ACTIEF','OPGEZEGD'),  PRIMARY[*] KEY (ABONNEENAAM, DIENSTNAAM),  FOREIGN KEY (ABONNEENAAM) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN1) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN2) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (DIENSTNAAM) REFERENCES DIENST(DIENSTNAAM) ON DELETE CASCADE ON UPDATE CASCADE) "; expected "), NOT, EXISTS, INTERSECTS, SELECT, FROM, WITH"; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum   date   not null,   verdubbeld   boolean    not null,  abonnementsoort varchar(20) check (abonnementsoort in ('MAAND', 'HALFJAAR','JAAR')),  abonnementstatus varchar(20)check (abonnementstatus in ('PROEF', 'ACTIEF','OPGEZEGD'),  primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade) [42001-193]
2016-12-08 21:05:23 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "CREATE TABLE IF NOT EXISTS ABONNEMENT (   ABONNEENAAM  VARCHAR(255) NOT NULL,  DIENSTNAAM  VARCHAR(255) NOT NULL,  ABONNEEDELEN1  VARCHAR(255)  NULL,  ABONNEEDELEN2  VARCHAR(255)  NULL,  STARTDATUM   DATE   NOT NULL,   VERDUBBELD   BOOLEAN    NOT NULL,  ABONNEMENTSOORT VARCHAR(20) NULL CHECK (ABONNEMENTSOORT IN ('MAAND', 'HALFJAAR','JAAR')),  ABONNEMENTSTATUS VARCHAR(20) NULL CHECK (ABONNEMENTSTATUS IN ('PROEF', 'ACTIEF','OPGEZEGD'),  PRIMARY[*] KEY (ABONNEENAAM, DIENSTNAAM),  FOREIGN KEY (ABONNEENAAM) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN1) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN2) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (DIENSTNAAM) REFERENCES DIENST(DIENSTNAAM) ON DELETE CASCADE ON UPDATE CASCADE) "; expected "), NOT, EXISTS, INTERSECTS, SELECT, FROM, WITH"; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum   date   not null,   verdubbeld   boolean    not null,  abonnementsoort varchar(20) null check (abonnementsoort in ('MAAND', 'HALFJAAR','JAAR')),  abonnementstatus varchar(20) null check (abonnementstatus in ('PROEF', 'ACTIEF','OPGEZEGD'),  primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade) [42001-193]
2016-12-08 21:06:27 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "CREATE TABLE IF NOT EXISTS ABONNEMENT (   ABONNEENAAM  VARCHAR(255) NOT NULL,  DIENSTNAAM  VARCHAR(255) NOT NULL,  ABONNEEDELEN1  VARCHAR(255)  NULL,  ABONNEEDELEN2  VARCHAR(255)  NULL,  STARTDATUM   DATE   NOT NULL,   VERDUBBELD   BOOLEAN    NOT NULL,  ABONNEMENTSOORT VARCHAR(20) NULL CHECK (ABONNEMENTSOORT IN ('MAAND', 'HALFJAAR','JAAR')),  ABONNEMENTSTATUS VARCHAR(20) NULL CHECK (ABONNEMENTSTATUS IN ('PROEF', 'ACTIEF','OPGEZEGD'),  PRIMARY[*] KEY (ABONNEENAAM, DIENSTNAAM),  FOREIGN KEY (ABONNEENAAM) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN1) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (ABONNEEDELEN2) REFERENCES ABONNEE(ABONNEENAAM) ON DELETE CASCADE ON UPDATE CASCADE,  FOREIGN KEY (DIENSTNAAM) REFERENCES DIENST(DIENSTNAAM) ON DELETE CASCADE ON UPDATE CASCADE;) "; expected "), NOT, EXISTS, INTERSECTS, SELECT, FROM, WITH"; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum   date   not null,   verdubbeld   boolean    not null,  abonnementsoort varchar(20) null check (abonnementsoort in ('MAAND', 'HALFJAAR','JAAR')),  abonnementstatus varchar(20) null check (abonnementstatus in ('PROEF', 'ACTIEF','OPGEZEGD'),  primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade;) [42001-193]
2016-12-08 21:08:21 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Table "ABONNEE" not found; SQL statement:
CREATE TABLE IF NOT EXISTS abonnement (   abonneenaam  varchar(255) not null,  dienstnaam  varchar(255) not null,  abonneedelen1  varchar(255)  null,  abonneedelen2  varchar(255)  null,  startdatum  date not null,   verdubbeld   boolean  not null,  abonnementsoort varchar(20) null check (abonnementsoort in ('MAAND', 'HALFJAAR','JAAR')),  abonnementstatus varchar(20) null check (abonnementstatus in ('PROEF', 'ACTIEF','OPGEZEGD')),  primary key (abonneenaam, dienstnaam),  foreign key (abonneenaam) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen1) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (abonneedelen2) references abonnee(abonneenaam) on delete cascade on update cascade,  foreign key (dienstnaam) references dienst(dienstnaam) on delete cascade on update cascade) [42102-193]
2016-12-08 21:09:44 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Cannot parse "DATE" constant "2016-12-08 21:09:44"; SQL statement:
INSERT INTO abonnement (abonneenaam, dienstnaam, abonneedelen1, abonneedelen2, startdatum, verdubbeld, abonnementsoort, abonnementstatus)VALUES ('500 belminuten', 'Eeg', null, null, '2016-12-08 21:09:44', FALSE, 'MAAND' ,'PROEF') -- ('500 belminuten', 'Eeg', NULL, NULL, '2016-12-08 21:09:44', FALSE, 'MAAND', 'PROEF') [22007-193]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:168)
	at org.h2.value.ValueDate.parse(ValueDate.java:81)
	at org.h2.value.Value.convertTo(Value.java:928)
	at org.h2.table.Column.convert(Column.java:149)
	at org.h2.command.dml.Insert.insertRows(Insert.java:143)
	at org.h2.command.dml.Insert.update(Insert.java:114)
	at org.h2.command.CommandContainer.update(CommandContainer.java:98)
	at org.h2.command.Command.executeUpdate(Command.java:258)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdateInternal(JdbcPreparedStatement.java:160)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdate(JdbcPreparedStatement.java:146)
	at oose.dea.datasource.AbonnementDAO.uitproberenDienst(AbonnementDAO.java:122)
	at oose.dea.datasource.AbonnementDAOIT.afterAddingOneItemTheListHasSizeOne(AbonnementDAOIT.java:71)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.lang.NumberFormatException: For input string: "08 21:09:44"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at org.h2.util.DateTimeUtils.parseDateValue(DateTimeUtils.java:317)
	at org.h2.value.ValueDate.parse(ValueDate.java:79)
	... 38 more
2016-12-08 21:12:51 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: Cannot parse "DATE" constant "2016-12-08 21:12:51"; SQL statement:
INSERT INTO abonnement (abonneenaam, dienstnaam, abonneedelen1, abonneedelen2, startdatum, verdubbeld, abonnementsoort, abonnementstatus)VALUES ('500 belminuten', 'Eeg', null, null, '2016-12-08 21:12:51', FALSE, 'MAAND' ,'PROEF') -- ('500 belminuten', 'Eeg', NULL, NULL, '2016-12-08 21:12:51', FALSE, 'MAAND', 'PROEF') [22007-193]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:168)
	at org.h2.value.ValueDate.parse(ValueDate.java:81)
	at org.h2.value.Value.convertTo(Value.java:928)
	at org.h2.table.Column.convert(Column.java:149)
	at org.h2.command.dml.Insert.insertRows(Insert.java:143)
	at org.h2.command.dml.Insert.update(Insert.java:114)
	at org.h2.command.CommandContainer.update(CommandContainer.java:98)
	at org.h2.command.Command.executeUpdate(Command.java:258)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdateInternal(JdbcPreparedStatement.java:160)
	at org.h2.jdbc.JdbcPreparedStatement.executeUpdate(JdbcPreparedStatement.java:146)
	at oose.dea.datasource.AbonnementDAO.uitproberenDienst(AbonnementDAO.java:122)
	at oose.dea.datasource.AbonnementDAOIT.afterAddingOneItemTheListHasSizeOne(AbonnementDAOIT.java:71)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.lang.NumberFormatException: For input string: "08 21:12:51"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at org.h2.util.DateTimeUtils.parseDateValue(DateTimeUtils.java:317)
	at org.h2.value.ValueDate.parse(ValueDate.java:79)
	... 38 more
